git clone xxx                 克隆仓库到本地
git clone xxx --depth=1       只克隆最近一次commit的一个分支,加快克隆的速度
git clone -b 分支名 仓库地址  克隆指定分支，比如git clone -b RELEASE.2021-06-17T00-10-46Z https://gitee.com/mirrors/minio.git
git log                       查看git提交记录
git log --oneline             简化显示信息，默认只展示简短的 commit id 和提交注释
git log --stat                显示被修改文件的修改统计信息
git log --graph --oneline --all
git show commitid


git remote -v          查看当前项目的远程git地址
git branch -a          查看远程的所有分支列表
git branch             查看本地的git分支

git status
git diff xxx           查询文件修改详情

git add xxx            将修改添加到暂存区
git commit -m "fix"    将暂存区内容添加到本地仓库中
git commit -am "fix"   可以省略使用git add命令将已跟踪文件放到暂存区
git push
git checkout -b xxx
git rebase -i commitID

全局配置（~/.gitconfig）
git config --global http.sslVerify "false"
git config --global core.quotepath false       显示中文
git config --global user.name "xxx"            全局用户名
git config --global user.email "xxx@gmail.com" 全局用户邮箱
git config --global http://alias.co checkout # 别名
git config --global core.editor "vim" # 设置Editor使用vim
git config --global color.ui true
git config --global --list
git config -l



git diff <$id1> <$id2> # 比较两次提交之间的差异
git diff <branch1>..<branch2> # 在两个分支之间比较
git diff --staged # 比较暂存区和版本库差异



撤销修改：
git reset head xxx     // 文件已经添加到暂存区
git checkout -- xxx

//上库之前，先做如下步骤
git stash                      把当前分支所有没有commit的代码先暂存起来，git stash save “save message”
git pull
git stash pop
git stash apply    与pop相似，但他不会在堆栈中删除这条缓存；git stash apply stash@{0}

git stash drop     删除单个缓存
git stash clear    全清

git stash show     显示与当前分支差异
git stash branch   指定或最新缓存创建分支？

git stash list     显示暂存区中的记录
git stash –keep-index   只会备份那些没有被 add 的文件

git restore --staged   //从暂存区中恢复某个文件
git reset        取消已经 add 的文件的备份

配置某个项目的用户
git config user.name chenzufei
git config user.email chenzufei@163.com

日志显示
git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative

分支合并
git merge featureA   合并后能分清除
git rebase featureA  合并后混合

这两者由什么差异
git add   进暂存区，git add 只是把文件加到 git 版本控制里
git stash 将所有未提交的修改（工作区和暂存区）保存至堆栈区中，用于后续恢复当前工作目录。

工作区   暂存区   缓存区（不存在）  版本库
                  堆栈区

submodule: 当前项目与子模块之间的依赖关系：子模块路径、子模块的远程仓库、子模块的版本号。

git submodule add <submodule_url>    //项目仓库中会多出两个文件：.gitmodules 和 project-sub-1
git submodule add https://github.com/miracleyoo/someSubmodule  src/submodulePath      //指定目录

git submodule init
git submodule update

git submodule foreach 'git pull origin master'


git submodule deinit <submodule_name>
git rm <submodule_name>
git commit -m "delete submodule_name"


git submodule update --init --recursive

在.gitsubm..中设置branch = dev就是拉去dev分支

通过软链接/硬链接到submodule
mklink /d/j sub-module ..\sub-module\       window
ln -s /path/to/src /path/to/dst             linux

# Clone a project with submodules
git clone --recursive


git checkout -b xxx  创建xxx分支并切换（git branch xxx; git checkout xxx）
git branch xxx       创建xxx分支，但不切换

参数	        功能	                                                场景
–hard	        清空工作区与缓存区	                                    放弃目标版本后所有的修改
–soft	        保留工作区与缓存区，但是把版本之间的差异存放在缓存区	合并多个commit
–mixed(或缺省)	保留工作区清空缓存区，把版本之间的差异存放在工作区	    1、有错误的commit需要修改；2、git reset HEAD清空缓存区

git reset用于撤销操作
git reset --hard   HEAD/HEAD^/xxx
          --soft
          --mixed
		  
		  
		  
git checkout:
切换分支                 git checkout xxx(branch name)
放弃对某个文件的修改     git checkout xxx(file)
新建分支                 git checkout -b xxx(branch name)


git push    将本地分支push到远程仓库


rebase：使用rebase，那么其他开发人员想看主分支的历史，就不是原来的历史了
merge：大部分公司其实会禁用rebase，不管是拉代码还是push代码统一都使用merge
        合并commit与普通commit不一样
git merge --no-ff <branch>


git rebase -i合并多次提交的实现
git reset：当commit的内容有错误，需要回撤到之前的某个版本时。


Git一般划分为3个区域，working directory 为当前工作区、stage/index为暂存区（git add后的代码就会存储在这部分）、repository则记录提交的历史（git comment后的代码会存在这里）

stage：阶段 staging area就是index
stash:隐藏  将工作区和索引区的文件暂时存放在堆上。


文件类型，是git cat-file -t
查看文件内容是git cat-file -p




其他
git rm --cached xxx