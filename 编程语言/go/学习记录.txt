
1、ubuntu 20.04升级go版本
原来的是1.16的版本，需要升级到1.20.3

首先下载go1.20.3.linux-amd64.tar.gz并解压
将go拷贝到/opt

删除老的go程序，创建软连接
cd /usr/bin/
ln -s /opt/go/bin/go go


修改/etc/profile，添加
export GOROOT=/opt/go
export GOBIN=$GOROOT/bin
export GOPATH=$HOME/
export PATH=$PATH:$GOBIN:$GOPATH

source /etc/profile


[root@localhost ~]# go version
go version go1.20.3 linux/amd64

2、go组成
包声明
引入包
函数
变量
语句 & 表达式
注释

3、包的导出
标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，外部可以使用

4、与c的对比
注释是一致的

{ 不能在单独的行上
每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾

Go语言的字符串连接可以通过 + 实现

var x int   //变量声明时，类型在变量之后
go没有三目运算符

函数由 func 开始声明  返回类型    定义顺序跟c不一样



5、标记
关键字：25个关键字，36 个预定义标识符
标识符：一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。
常量
字符串，符号

6、数据类型
布尔型
数字类型
字符串
派生： 指针、数组、结构体、通道(Channel)、函数、切片、接口、集合（map）

变量声明:
var a int
var a = 1      自动推导，但python都不需要前面加var
a:= 1          函数体内使用

疑问：go语言函数内的局部变量是在堆上还是栈上？heap or the stack

go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。
C/C++的逻辑非常清楚：简单逻辑是，声明的局部变量分配在栈，通过动态申请(malloc, new)的内存在堆里。

对于动态new出来的局部变量，go语言编译器也会根据是否有逃逸行为来决定是分配在堆还是栈，而不是直接分配在堆中。

运算符：算术、关系、逻辑、位、赋值、其他



语句控制：条件， 循环，

数组(array)
指针
结构体
切片（slice），python中就是list(slice)
范围（range)   数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对

for key, value := range oldMap {
    newMap[key] = value
}

集合  

var siteMap map[string]string
siteMap = make(map[string]string)

m := make(map[string]int)



递归函数
类型转换；

字符串转整形：
var str string = "10"
var num int
num, _ = strconv.Atoi(str)

整形转字符串
num := 123
str := strconv.Itoa(num)


接口： 不同类型绑定到一组公共的方法上，从而实现多态。  没怎么理解。
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   ...
   method_namen [return_type]
}


错误处理    没怎么理解

go并发：goroutine  go 函数名( 参数列表 )       协程(coroutine)

通道（channel）： 用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。

ch := make(chan int)
ch <- v    // 把 v 发送到通道 ch
v := <-ch  // 从 ch 接收数据
           // 并把值赋给 v


开发工具：
vscode + go插件
GoLand

7、遗留：
接口类型？  interface{}


go无法启线程，多进程？ 进程(Process),线程(Thread),协程(Coroutine,也叫轻量级线程)

go：Go的os包，os.StartProcess
c语言：进程 fork，execv

thread

Go 语言中没有“类”的概念，也不支持像继承这种面向对象的概念。有struct和interface
在go语言中不需要显示的去实现接口，只要一个类型实现了该接口中定义的所有方法就是默认实现了该接口，而且允许多个类型都实现该接口，也允许一个类型实现多个接口。


Go语言的内存回收机制
析构函数，Go提供了defer的关键字




8、Golang标准库
http://doc.golang.ltd/

（1）输入输出 (Input/Output)
io 为 IO 原语（I/O primitives）提供基本的接口
io/ioutil 封装一些实用的 I/O 函数
fmt 实现格式化 I/O，类似 C 语言中的 printf 和 scanf
bufio 实现带缓冲I/O

（2）文本（字符串）
strings
strconv 包提供了基本数据类型和字符串之间的转换。

Go 代码使用 UTF-8 编码（且不能带 BOM）
第三方库：mahonia — 纯 Go 语言实现的字符集转换库


（3）数据结构与算法
sort 包包含基本的排序方法
index/suffixary 包实现了后缀数组相关算法
container 包提供了对 heap、list 和 ring 这 3 种数据结构的底层支持。

（4）日期与时间
time
math 包实现的就是数学函数计算。

（5）文件系统
os 包
path/filepath 包

Go 语言从 1.16 开始增加了 io/fs 包
os/exec，运行外部命令

（6）数据持久存储与交换

database/sql 包     SQL/SQL-like 数据库的操作
数据交换： JSON、XML 等   gob包
           protobuf、msgpack

（7）http
net/http/httptest 包专门用于进行 http Web 开发测试

（8）其他
在 Go 中，通过 clone() 系统调用来创建线程
expvar 
sync 包



Go 语言的官方网站是 http://golang.org
中国专属的官方网站：http://golang.google.cn 
2019 年 2 月，Go 团队又注册了一个新的域名：go.dev

Go 程序包档案集散地的 http://godoc.org
                      pkg.go.dev
					  

2007年：Go 语言在 Google 内部孵化。
2009年11月10日，开源
2012年：Go 正式版本1.0 发布。
2015年：Go 1.5 正式版本发布。  优化 GC 实现    从 Go 1.5 版本后，完全使用 Go 语言自身进行编写。
2016年：Go 1.6 和 Go 1.7 正式版本发布。在2016年流行起来
2020年：Go 1.14 和 Go 1.15 正式版本发布。
2021年：Go 1.16             Go 官方对 go install 命令进行了改进，使它可以接受一种版本后
        Go 1.17
2022年：Go 1.18  泛型
        Go 1.19
2023年：Go 1.20

云原生：DevOps+持续交付+微服务+容器
go install example.com/cmd/pkg@v1.0.0    go get
go module 机制

go build
go test


